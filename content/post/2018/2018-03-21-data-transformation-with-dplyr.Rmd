---
title: 使用dplyr进行数据转换
author: 王诗翔
date: '2018-03-21'
slug: data-transformation-with-dplyr
categories:
  - R
  - 数据分析
tags:
  - notebook
  - dplyr
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

该部分学习内容来自《R for Data Science》。

在对数据进行可视化之前我们往往需要进行数据转换以得到可视化所需要的数据内容与格式。这里我们使用`dplyr`包操作2013年纽约市的航班起飞数据集（2013）。

## 准备

这部分我们聚焦于如何使用`dplyr`包，除`ggplot2`的另一个**tidyverse**核心成员。我们将使用`nyclights13`数据包解释关键的概念并使用`ggplot2`帮助理解数据。

```{r, warning=FALSE,collapse=TRUE}
# 导入包
library(nycflights13) # 请确保在使用前已经安装好这些包
library(tidyverse)
```

注意一下你导入`tidyverse`包时给出的冲突信息（Conflicts），它告诉你**dplyr**覆盖了R基础包中的函数。**如果你想要在载入`tidyverse`包后仍然使用这些函数，你需要使用函数的全名`stats::filter()`和`stats::lag()`进行调用。**


### nycflights13 

我们将使用`nycflights13::flights`来探索`dplyr`包基本的数据操作**动词**。该数据集包含2013年336,776次航班起飞数据，来自美国交通统计局。

```{r, collapse=TRUE}
flights
```

与基本包显示的普通数据集输出不同，这里适配地显示了在一个屏幕前几行和所有的列（我们可以使用`View(flights）`在Rstudio中查看数据集的所有信息。输出显示不同的原因是这个数据集是一个*Tibble*。**Tibbles**都是数据框`data.frame`，但经过改良以便于更好（在`tidyverse`生态中）工作。现在我们不必纠结于这些差异，在后续内容中我们会进行学习。

你可能已经注意到每个列名下面有**三到四个字母的缩写**。它们描述了每个变量的类型：

* `int`代表整数
* `dbl`代表浮点数或者实数
* `chr`代表字符向量或者字符串
* `dttm`代表日期-时间

还有其他三种数据类型在本部分不会使用到，但后续我们会接触：

* `lgl`代表逻辑向量，只含`TRUE`和`FALSE`
* `fctr`代表因子，R用它来代表含固定可能值的分类变量
* `date`代表日期

### dplyr基础

这部分我们学习5个关键的`dplyr`函数，它可以让我们解决遇到的大部分数据操作问题：

* 根据值选择观察（记录），`filter()`
* 对行重新排序，`arrange()`
* 根据名字选择变量，`select()`
* 根据已知的变量创建新的变量，`mutate()`
* 将许多值塌缩为单个描述性汇总，`summarize()`

这些函数都可以通过`group_by()`衔接起来，该函数改变上述每个函数的作用域，**从操作整个数据集到按组与组操作**。这六个函数提供了数据操作语言的动词。

所有的动词工作都非常相似：

1. 第一个参数都是数据框
2. 随后的参数描述了使用变量名（不加引号）对数据框做什么
3. 结果是一个新的数据框

这些属性一起便利地将多个简单步骤串联起来得到一个复杂的操作（结果）。让我们实际来看看这些动词是怎么工作的。

## 使用filter()过滤行

`filter()`允许我们根据观测值来对数据集取子集。第一个参数是数据框的名字，第二和随后的参数是用于过滤数据框的表达式。

比如，我们可以选择所有一月一号的航班：

```{r, collapse=TRUE}
filter(flights, month == 1, day == 1)
```

这一行代码`dplyr`执行了过滤操作并返回了一个新的数据框。**dplyr从不修改输入数据，所以如果你想要保存数据，必须使用`<-`进行赋值**：

```{r, collapse=TRUE}
jan1 <- filter(flights, month == 1, day == 1)
```

R要么输出结果，要么将结果保存到一个变量。如果我们想要同时做到这一点，你可以把赋值放在括号里：

```{r, collapse=TRUE}
(dec25 <- filter(flights, month == 12, day == 25))
```


### 比较

想要有效地过滤，你必须知道怎么利用比较操作符来选择观测值。R提供了标准的比较符：`>`,`>=`,`<=`,`!=`和`==`。

如果你是初学R，一个常见的错误是用`=`而不是`==`来检测相等。如果这种情况发生了，你会收到报错信息：

```{r, collapse=TRUE, eval=FALSE}
filter(flights, month = 1)
#> Error: `month` (`month = 1`) must not be named, do you need `==`?
```

另一个你在使用`==`时可能遭遇的常见问题是**浮点数**。下面的结果可能会让你惊掉大牙：

```{r, collapse=TRUE}
sqrt(2) ^ 2 == 2
1/49 * 49 == 1
```

### 逻辑操作符

`&`是与，`|`是或，`!`是非。

下面代码找到在十一月或十二月起飞的所有航班：

```{r, collapse=TRUE}
filter(flights, month == 11 | month == 12)
```

**注意**，你不能写成`filter(flights, month == 11 | 12)`，（虽然语义上讲的通）对于R而言，它会先计算`11|12`得到`1`，然后计算`month == 1`，这就不是我们需要的了！

解决这种问题的一种有用简写为`x %in% y `。这将选择符合`x`属于`y`的行（`x`是`y`中的一个值）。我们可以用它重写前面的代码：

```{r, eval=FALSE}
nov_dec <- filter(flights, month %in% c(11, 12))
```


### 缺失值

**NA**代表未知值或者称为缺失值，它是能“传染”的，几乎任何涉及未知值的操作都会是一个未知值。

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```

最让人困惑的结果是这个：

```{r}
NA == NA
```

最简单理解为什么这是`TRUE`的方式是带入一点语境：

```{r}
# 把x看作小明的年龄，我们不知道他多大
x <- NA

# 把y看作小红的年龄，我们不知道她多大
y <- NA

# 小明和小红一样大吗？
x == y

# 我们不知道
```

如果你想确定一个值是不是缺失了，使用`is.na()`：

```{r}
is.na(x)
```

`filter()`仅仅会包含条件是`TRUE`的行，把是`FALSE`或者`NA`的行排除。如果你想要保留缺失值，你可以显式地指定：

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

### 练习

1. 寻找满足以下条件的所有航班：
    * 有一次大于等于2小时的航班抵达延误
    * 飞去Houston（IAH或者HOU）
    * 航空公司为United，American或者Delta （应当缩写是UA和DL）
    * 在夏天起飞（July，August和September）
    * 抵达延误超过两小时，但起飞时间正常
    * 起飞时间在午夜到6.a.m之间（包含）
2. 另一个有用的**dplyr**过滤助手是`between()`函数。它是做什么的？你可以使用它简化用于解决前面问题的代码吗？
3. 有多少航班有一个缺失的`dep_time`？其他缺失的变量有哪些？这些行表示什么呢？
4. 为什么`NA ^ 0`不是缺失值？为什么`NA | TRUE`不是缺失值？为什么`FALSE & NA`不是缺失值？你可以弄懂它们的基本原理吗?


```{r answer_filter}
# 1
# 有一次大于等于2小时的航班抵达延误？
nrow(filter(flights, arr_delay >= 120))
# 有很多抵达延误超过两小时的

# 飞去Houston（IAH或者HOU）？
nrow(filter(flights, dest %in% c("IAH", "HOU")))
# 或者
nrow(filter(flights, dest == "IAH" | dest == "HOU"))

# 航空公司为United，American或者Delta （应当缩写是UA和DL）
nrow(filter(flights, carrier %in% c("UA", "DL")))

# 在夏天起飞（July，August和September）
nrow(filter(flights, month >=7 & month <=9))

# 抵达延误超过两小时，但起飞时间正常
nrow(filter(flights, dep_delay == 0, arr_delay >= 120))

# 起飞时间在午夜到6.a.m之间（包含）
nrow(filter(flights, hour >= 0 & hour <= 6))
```

